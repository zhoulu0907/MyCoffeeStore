# MyCoffeeStore 性能检查清单

> 版本：1.0
> 创建时间：2026-02-26
> 适用范围：前端 + 后端 + 数据库 + 用户体验

---

## 使用说明

本清单用于 MyCoffeeStore 项目的性能审查。请在以下场景使用：

1. 开发阶段的性能优化
2. 代码审查阶段的性能检查
3. 上线前的性能验证
4. 定期性能巡检和优化

---

## 1. 前端性能

### 1.1 加载性能

| 检查项 | 目标指标 | 实际值 | 通过 | 问题记录 |
|--------|----------|--------|------|----------|
| **首次内容绘制 (FCP)** | < 1.8s | [ ] | [ ] | |
| **最大内容绘制 (LCP)** | < 2.5s | [ ] | [ ] | |
| **首次输入延迟 (FID)** | < 100ms | [ ] | [ ] | |
| **累积布局偏移 (CLS)** | < 0.1 | [ ] | [ ] | |
| **首次字节时间 (TTFB)** | < 600ms | [ ] | [ ] | |
| **DOM 内容加载** | < 1s | [ ] | [ ] | |
| **页面完全加载** | < 3s | [ ] | [ ] | |

**测试方法**：
```bash
# 使用 Lighthouse 进行性能测试
npm install -g lighthouse
lighthouse https://your-website.com --view
```

---

### 1.2 资源优化

| 检查项 | 标准 | 通过 | 问题记录 |
|--------|------|------|----------|
| **图片优化** | 图片使用 WebP 格式，已压缩 | [ ] | |
| **图片懒加载** | 非首屏图片懒加载 | [ ] | |
| **字体优化** | 使用 font-display: swap | [ ] | |
| **CSS 压缩** | CSS 文件已压缩 | [ ] | |
| **JS 压缩** | JS 文件已压缩 | [ ] | |
| **移除未使用代码** | Tree-shaking 移除未使用代码 | [ ] | |
| **资源压缩** | 启用 Gzip/Brotli 压缩 | [ ] | |

**正确示例**：
```typescript
// 图片懒加载
import { lazy, Suspense } from 'react';

const CoffeeDetail = lazy(() => import('./pages/CoffeeDetail'));

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <CoffeeDetail />
    </Suspense>
  );
}

// 图片组件
<img
  src={imageUrl}
  loading="lazy"
  decoding="async"
  alt={name}
/>
```

```javascript
// Vite 配置 - 构建优化
// vite.config.ts
export default defineConfig({
  build: {
    // 代码分割
    rollupOptions: {
      output: {
        manualChunks: {
          'react-vendor': ['react', 'react-dom'],
          'ui-vendor': ['antd'],
        },
      },
    },
    // 压缩
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true,
      },
    },
  },
  server: {
    // 开发环境启用 gzip
    headers: {
      'Content-Encoding': 'gzip',
    },
  },
});
```

---

### 1.3 代码优化

| 检查项 | 标准 | 通过 | 问题记录 |
|--------|------|------|----------|
| **组件懒加载** | 路由级别的代码分割 | [ ] | |
| **React.memo** | 组件适当使用 memo 优化 | [ ] | |
| **useMemo** | 计算密集操作使用 useMemo | [ ] | |
| **useCallback** | 回调函数使用 useCallback | [ ] | |
| **虚拟滚动** | 长列表使用虚拟滚动 | [ ] | |
| **防抖节流** | 搜索/滚动事件使用防抖节流 | [ ] | |

**正确示例**：
```typescript
// React.memo 优化组件
import React, { memo } from 'react';

interface CoffeeCardProps {
  coffee: Coffee;
  onAddToCart: (id: number) => void;
}

export const CoffeeCard = memo<CoffeeCardProps>(
  ({ coffee, onAddToCart }) => {
    return (
      <div className="coffee-card">
        {/* ... */}
      </div>
    );
  },
  (prevProps, nextProps) => {
    // 自定义比较逻辑
    return prevProps.coffee.id === nextProps.coffee.id;
  }
);

// useMemo 优化计算
const CoffeeList: React.FC = () => {
  const [coffees, setCoffees] = useState<Coffee[]>([]);
  const [filter, setFilter] = useState<string>('all');

  // 缓存过滤结果
  const filteredCoffees = useMemo(() => {
    return coffees.filter(coffee =>
      filter === 'all' || coffee.category === filter
    );
  }, [coffees, filter]);

  // 缓存计算结果
  const totalPrice = useMemo(() => {
    return filteredCoffees.reduce((sum, coffee) => sum + coffee.price, 0);
  }, [filteredCoffees]);

  return (
    <div>
      {filteredCoffees.map(coffee => (
        <CoffeeCard key={coffee.id} coffee={coffee} />
      ))}
    </div>
  );
};

// useCallback 优化回调
const SearchBar: React.FC = () => {
  const [keyword, setKeyword] = useState('');

  // 防抖搜索
  const debouncedSearch = useMemo(
    () => debounce((value: string) => {
      // 执行搜索
    }, 300),
    []
  );

  const handleInputChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setKeyword(value);
    debouncedSearch(value);
  }, [debouncedSearch]);

  return <input value={keyword} onChange={handleInputChange} />;
};
```

---

### 1.4 网络性能

| 检查项 | 目标指标 | 实际值 | 通过 | 问题记录 |
|--------|----------|--------|------|----------|
| **总请求数** | < 50 个 | [ ] | [ ] | |
| **总传输大小** | < 1MB (首屏) | [ ] | [ ] | |
| **资源缓存** | 静态资源有缓存策略 | [ ] | [ ] | |
| **预加载** | 关键资源使用预加载 | [ ] | [ ] | |
| **预连接** | 重要域名使用预连接 | [ ] | [ ] | |

**正确示例**：
```html
<!-- index.html -->
<head>
  <!-- DNS 预解析 -->
  <link rel="dns-prefetch" href="https://api.example.com">

  <!-- 预连接 -->
  <link rel="preconnect" href="https://api.example.com">

  <!-- 预加载关键资源 -->
  <link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/images/hero.jpg" as="image">

  <!-- 预获取下一页资源 -->
  <link rel="prefetch" href="/api/coffee/list">
</head>
```

```javascript
// Service Worker 缓存策略
// sw.js
const CACHE_NAME = 'coffee-store-v1';
const urlsToCache = [
  '/',
  '/static/css/main.css',
  '/static/js/main.js',
  '/api/coffee/list',
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll(urlsToCache))
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      // 缓存优先，回退到网络
      return response || fetch(event.request);
    })
  );
});
```

---

### 1.5 渲染性能

| 检查项 | 标准 | 通过 | 问题记录 |
|--------|------|------|----------|
| **帧率 (FPS)** | ≥ 55 FPS | [ ] | |
| **无长任务** | 无 > 50ms 的长任务 | [ ] | |
| **重绘重排** | 最小化重绘和重排 | [ ] | |
| **合成层** | 使用 transform/opacity 动画 | [ ] | |
| **will-change** | 合理使用 will-change 属性 | [ ] | |

**正确示例**：
```css
/* 使用 GPU 加速 */
.coffee-card {
  /* 使用 transform 替代 top/left */
  transform: translateY(0);
  transition: transform 0.3s ease;
}

.coffee-card:hover {
  transform: translateY(-4px);
}

/* 使用 opacity 替代 visibility */
.fade-enter {
  opacity: 0;
}

.fade-enter-active {
  opacity: 1;
  transition: opacity 0.3s ease;
}

/* 使用 will-change 提示浏览器优化 */
.animated-element {
  will-change: transform, opacity;
}
```

---

## 2. 后端性能

### 2.1 API 响应时间

| 检查项 | 目标指标 | 实际值 | 通过 | 问题记录 |
|--------|----------|--------|------|----------|
| **P50 响应时间** | < 200ms | [ ] | [ ] | |
| **P95 响应时间** | < 500ms | [ ] | [ ] | |
| **P99 响应时间** | < 1000ms | [ ] | [ ] | |
| **错误率** | < 0.1% | [ ] | [ ] | |
| **可用性** | > 99.9% | [ ] | [ ] | |

**测试方法**：
```bash
# 使用 Apache Bench 进行压力测试
ab -n 1000 -c 10 https://api.example.com/api/coffee/list

# 使用 wrk 进行性能测试
wrk -t4 -c100 -d30s https://api.example.com/api/coffee/list
```

---

### 2.2 数据库性能

| 检查项 | 目标指标 | 实际值 | 通过 | 问题记录 |
|--------|----------|--------|------|----------|
| **查询响应时间** | < 100ms (P95) | [ ] | [ ] | |
| **慢查询数量** | = 0 | [ ] | [ ] | |
| **连接池使用率** | < 80% | [ ] | [ ] | |
| **索引使用率** | > 95% | [ ] | [ ] | |
| **锁等待时间** | < 10ms | [ ] | [ ] | |

**正确示例**：
```sql
-- 添加索引优化查询
CREATE INDEX idx_coffee_category ON coffee(category);
CREATE INDEX idx_coffee_status ON coffee(status);
CREATE INDEX idx_order_user_id ON `order`(user_id);
CREATE INDEX idx_order_create_time ON `order`(create_time);

-- 分析慢查询
-- 启用慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;

-- 查看慢查询
SELECT * FROM mysql.slow_log ORDER BY query_time DESC LIMIT 10;

-- 使用 EXPLAIN 分析查询
EXPLAIN SELECT * FROM coffee WHERE category = 'latte' AND status = 1;
```

```java
// MyBatis-Flex 查询优化
@Service
public class CoffeeServiceImpl implements CoffeeService {

    @Override
    public Page<CoffeeVO> searchCoffees(CoffeeSearchDTO dto) {
        // 使用 QueryWrapper 构建高效查询
        QueryWrapper query = QueryWrapper.create()
            .select(COFFEE.ID, COFFEE.NAME, COFFEE.PRICE, COFFEE.IMAGE_URL)
            .from(COFFEE)
            .where(COFFEE.STATUS.eq(1))
            .and(COFFEE.CATEGORY.eq(dto.getCategory(), dto.getCategory() != null))
            .and(COFFEE.NAME.like(dto.getKeyword(), dto.getKeyword() != null))
            .orderBy(COFFEE.CREATE_TIME.desc())
            .page(dto.getPageNum(), dto.getPageSize());

        // 只查询需要的字段，避免 SELECT *
        return coffeeMapper.paginate(query).convert(this::toVO);
    }
}
```

---

### 2.3 缓存策略

| 检查项 | 标准 | 通过 | 问题记录 |
|--------|------|------|----------|
| **热点数据缓存** | 热点数据已缓存 | [ ] | |
| **缓存穿透保护** | 有缓存穿透保护 | [ ] | |
| **缓存雪崩保护** | 有缓存雪崩保护 | [ ] | |
| **缓存更新策略** | 有合理的缓存更新策略 | [ ] | |
| **缓存命中率** | > 80% | [ ] | [ ] |

**正确示例**：
```java
// Spring Cache 配置
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(10))
            .disableCachingNullValues()
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(redisConnectionFactory())
            .cacheDefaults(config)
            .build();
    }
}

// 缓存使用
@Service
public class CoffeeServiceImpl implements CoffeeService {

    // 缓存咖啡列表
    @Cacheable(value = "coffee:list", key = "'all'", unless = "#result.isEmpty()")
    public List<CoffeeVO> getAllCoffees() {
        return coffeeMapper.selectList()
            .stream()
            .map(this::toVO)
            .collect(Collectors.toList());
    }

    // 更新时清除缓存
    @CacheEvict(value = "coffee:list", key = "'all'")
    public void updateCoffee(CoffeeDTO dto) {
        coffeeMapper.updateById(toEntity(dto));
    }

    // 缓存穿透保护
    @Cacheable(value = "coffee:detail", key = "#id", unless = "#result == null")
    public CoffeeVO getCoffeeDetail(Long id) {
        return coffeeMapper.selectOneById(id)
            .map(this::toVO)
            .orElse(null);
    }
}

// 缓存雪崩保护 - 设置随机过期时间
@Cacheable(value = "coffee:detail", key = "#id")
public CoffeeVO getCoffeeDetail(Long id) {
    Random random = new Random();
    int ttl = 600 + random.nextInt(300); // 10-15 分钟
    // ...
}
```

---

### 2.4 并发性能

| 检查项 | 目标指标 | 实际值 | 通过 | 问题记录 |
|--------|----------|--------|------|----------|
| **最大并发数** | ≥ 100 | [ ] | [ ] | |
| **线程池配置** | 线程池配置合理 | [ ] | [ ] | |
| **连接池配置** | 数据库连接池配置合理 | [ ] | [ ] | |
| **异步处理** | 耗时操作异步处理 | [ ] | [ ] |

**正确示例**：
```yaml
# application.yml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000

  task:
    execution:
      pool:
        core-size: 10
        max-size: 20
        queue-capacity: 100
        keep-alive: 60s
```

```java
// 异步处理
@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean
    public Executor asyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("async-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}

@Service
public class OrderServiceImpl implements OrderService {

    @Async
    public void sendOrderNotification(Long orderId) {
        // 异步发送订单通知
    }
}
```

---

### 2.5 JVM 性能

| 检查项 | 标准 | 通过 | 问题记录 |
|--------|------|------|----------|
| **JVM 参数** | JVM 参数配置合理 | [ ] | |
| **堆内存使用** | < 80% | [ ] | [ ] | |
| **GC 频率** | Full GC 频率 < 1次/小时 | [ ] | [ ] | |
| **GC 停顿时间** | < 100ms | [ ] | [ ] | |

**正确示例**：
```bash
# JVM 参数配置
java -jar app.jar \
  -Xms512m \
  -Xmx1024m \
  -XX:+UseG1GC \
  -XX:MaxGCPauseMillis=100 \
  -XX:+HeapDumpOnOutOfMemoryError \
  -XX:HeapDumpPath=/logs/heapdump.hprof \
  -XX:+PrintGCDetails \
  -XX:+PrintGCDateStamps \
  -Xloggc:/logs/gc.log
```

---

## 3. 用户体验性能

### 3.1 交互响应

| 检查项 | 目标指标 | 实际值 | 通过 | 问题记录 |
|--------|----------|--------|------|----------|
| **点击响应** | < 100ms | [ ] | [ ] | |
| **页面切换** | < 300ms | [ ] | [ ] | |
| **表单提交** | < 500ms | [ ] | [ ] | |
| **搜索响应** | < 300ms | [ ] | [ ] | |

---

### 3.2 加载体验

| 检查项 | 标准 | 通过 | 问题记录 |
|--------|------|------|----------|
| **加载提示** | 异步操作有加载提示 | [ ] | |
| **骨架屏** | 列表使用骨架屏 | [ ] | |
| **进度指示** | 长时间操作有进度指示 | [ ] | |
| **错误提示** | 错误信息友好 | [ ] | |

**正确示例**：
```typescript
// 骨架屏组件
const CoffeeList: React.FC = () => {
  const { data, loading } = useCoffeeList();

  if (loading) {
    return (
      <div className="coffee-list-skeleton">
        {[...Array(6)].map((_, i) => (
          <CoffeeCardSkeleton key={i} />
        ))}
      </div>
    );
  }

  return (
    <div className="coffee-list">
      {data.map(coffee => (
        <CoffeeCard key={coffee.id} coffee={coffee} />
      ))}
    </div>
  );
};

// 加载状态
const OrderButton: React.FC = () => {
  const [loading, setLoading] = useState(false);

  const handleCreateOrder = async () => {
    setLoading(true);
    try {
      await createOrder();
      message.success('订单创建成功');
    } catch (error) {
      message.error('订单创建失败，请重试');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Button onClick={handleCreateOrder} loading={loading}>
      创建订单
    </Button>
  );
};
```

---

## 4. 移动端性能

### 4.1 移动端加载

| 检查项 | 目标指标 | 实际值 | 通过 | 问题记录 |
|--------|----------|--------|------|----------|
| **首屏加载** | < 3s (4G) | [ ] | [ ] | |
| **资源大小** | < 500KB | [ ] | [ ] | |
| **触摸响应** | < 100ms | [ ] | [ ] | |

---

### 4.2 移动端优化

| 检查项 | 标准 | 通过 | 问题记录 |
|--------|------|------|----------|
| **触摸优化** | 按钮大小 ≥ 44x44px | [ ] | |
| **滚动流畅** | 滚动帧率 ≥ 55 FPS | [ ] | |
| **响应式图片** | 使用 srcset 提供合适尺寸 | [ ] | |

**正确示例**：
```html
<!-- 响应式图片 -->
<img
  src="/images/coffee-small.jpg"
  srcset="
    /images/coffee-small.jpg 400w,
    /images/coffee-medium.jpg 800w,
    /images/coffee-large.jpg 1200w
  "
  sizes="(max-width: 600px) 400px, (max-width: 1200px) 800px, 1200px"
  alt="Coffee"
/>
```

---

## 5. 性能监控

### 5.1 前端监控

| 检查项 | 标准 | 通过 | 问题记录 |
|--------|------|------|----------|
| **Core Web Vitals** | 配置 Core Web Vitals 监控 | [ ] | |
| **错误监控** | 配置前端错误监控 | [ ] | |
| **性能指标上报** | 定期上报性能指标 | [ ] | |

**正确示例**：
```typescript
// 性能监控
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

getCLS(console.log);
getFID(console.log);
getFCP(console.log);
getLCP(console.log);
getTTFB(console.log);

// 上报性能数据
function sendToAnalytics(metric) {
  const body = JSON.stringify(metric);
  const url = 'https://analytics.example.com/analytics';

  if (navigator.sendBeacon) {
    navigator.sendBeacon(url, body);
  } else {
    fetch(url, { body, method: 'POST', keepalive: true });
  }
}
```

---

### 5.2 后端监控

| 检查项 | 标准 | 通过 | 问题记录 |
|--------|------|------|----------|
| **APM 监控** | 配置 APM 监控 | [ ] | |
| **慢接口监控** | 监控慢接口 | [ ] | |
| **错误监控** | 监控应用错误 | [ ] | |
| **资源监控** | 监控 CPU、内存、磁盘 | [ ] | |

**正确示例**：
```yaml
# Spring Boot Actuator 配置
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
```

```yaml
# Prometheus 配置
scrape_configs:
  - job_name: 'my-coffee-store'
    metrics_path: '/actuator/prometheus'
    scrape_interval: 15s
    static_configs:
      - targets: ['localhost:8080']
```

---

## 6. 性能检查总结

### 性能指标汇总

| 类别 | 检查项 | 通过数 | 不通过数 | 通过率 |
|------|--------|--------|----------|--------|
| 前端性能 | 25 | [ ] | [ ] | [ ] |
| 后端性能 | 20 | [ ] | [ ] | [ ] |
| 用户体验 | 8 | [ ] | [ ] | [ ] |
| 移动端性能 | 6 | [ ] | [ ] | [ ] |
| 性能监控 | 6 | [ ] | [ ] | [ ] |
| **总计** | **65** | [ ] | [ ] | [ ] |

### 性能等级评定

- [ ] **优秀**：通过率 ≥ 95%，核心指标优秀
- [ ] **良好**：通过率 ≥ 85%，核心指标良好
- [ ] **合格**：通过率 ≥ 70%，核心指标达标
- [ ] **不合格**：通过率 < 70% 或核心指标不达标

### 性能优化建议

（根据检查结果，提供具体的性能优化建议和优先级）

---

*文档版本：1.0*
*最后更新：2026-02-26*

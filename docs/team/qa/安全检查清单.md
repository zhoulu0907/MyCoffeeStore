# MyCoffeeStore 安全检查清单

> 版本：1.0
> 创建时间：2026-02-26
> 适用范围：前端 + 后端 + 数据库 + 部署

---

## 使用说明

本清单用于 MyCoffeeStore 项目的安全审查。请在以下场景使用：

1. 代码提交前的自我检查
2. 代码审查阶段的安全验证
3. 上线前的安全审计
4. 定期安全巡检

---

## 1. 注入攻击防护

### 1.1 SQL 注入防护

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **参数化查询** | 所有数据库查询使用参数绑定 | [ ] | |
| **ORM 框架** | 使用 MyBatis-Flex 框架自动防护 | [ ] | |
| **LIKE 查询** | LIKE 查询使用参数绑定 | [ ] | |
| **IN 查询** | IN 查询使用参数列表 | [ ] | |
| **动态 SQL** | 动态 SQL 经过安全审查 | [ ] | |

**正确示例**：
```java
// 正确 - 使用参数绑定
@Select("SELECT * FROM coffee WHERE id = #{id}")
Coffee selectById(Long id);

// 正确 - MyBatis-Flex QueryWrapper
QueryWrapper query = QueryWrapper.create()
    .select()
    .from(COFFEE)
    .where(COFFEE.NAME.like(keyword));  // 自动参数化

// 错误 - 字符串拼接
// String sql = "SELECT * FROM coffee WHERE name = '" + name + "'";
```

---

### 1.2 XSS (跨站脚本) 防护

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **输入过滤** | 前端对用户输入进行验证和过滤 | [ ] | |
| **输出转义** | 后端输出 HTML 时进行转义 | [ ] | |
| **React 自动转义** | 不使用 `dangerouslySetInnerHTML` | [ ] | |
| **CSP 策略** | 配置内容安全策略 | [ ] | |
| **富文本过滤** | 富文本内容使用 DOMPurify 净化 | [ ] | |

**正确示例**：
```typescript
// React 自动转义 - 安全
<div>{userInput}</div>

// 如需渲染 HTML - 使用 DOMPurify
import DOMPurify from 'dompurify';
const clean = DOMPurify.sanitize(userInput);
<div dangerouslySetInnerHTML={{ __html: clean }} />
```

```java
// 后端配置 XSS 过滤器
@Configuration
public class SecurityConfig {
    @Bean
    public FilterRegistrationBean<XssFilter> xssFilter() {
        FilterRegistrationBean<XssFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new XssFilter());
        registration.addUrlPatterns("/*");
        return registration;
    }
}
```

---

### 1.3 CSRF (跨站请求伪造) 防护

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **CSRF Token** | 所有写操作验证 CSRF Token | [ ] | |
| **SameSite Cookie** | Cookie 设置 SameSite 属性 | [ ] | |
| **Origin 验证** | 验证请求来源 | [ ] | |
| **双重提交** | 敏感操作使用双重提交 Cookie | [ ] | |

**正确示例**：
```java
// Spring Security CSRF 配置
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            );
        return http.build();
    }
}
```

```typescript
// 前端发送 CSRF Token
const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');

axios.post('/api/order/create', data, {
    headers: {
        'X-CSRF-Token': csrfToken
    }
});
```

---

### 1.4 命令注入防护

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **避免命令执行** | 不使用 Runtime.exec() 等方法 | [ ] | |
| **参数白名单** | 必须执行命令时使用白名单验证 | [ ] | |

---

## 2. 认证与授权

### 2.1 用户认证

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **密码加密** | 使用 BCrypt 等安全加密算法 | [ ] | |
| **密码强度** | 强制复杂密码（大小写+数字+符号） | [ ] | |
| **登录限制** | 实施登录失败次数限制 | [ ] | |
| **JWT 安全** | JWT 使用强密钥签名 | [ ] | |
| **Token 过期** | Token 有合理的过期时间 | [ ] | |
| **刷新机制** | Token 过期有刷新机制 | [ ] | |

**正确示例**：
```java
// BCrypt 密码加密
private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

public void register(String password) {
    String encodedPassword = passwordEncoder.encode(password);
    // 存储加密后的密码
}

// 密码验证
public boolean login(String rawPassword, String encodedPassword) {
    return passwordEncoder.matches(rawPassword, encodedPassword);
}
```

```java
// JWT 配置
@Configuration
public class JwtConfig {
    // 密钥长度至少 256 位
    private static final String SECRET_KEY = "your-very-long-secret-key-at-least-256-bits";

    @Bean
    public JwtUtil jwtUtil() {
        return new JwtUtil(SECRET_KEY, 86400000); // 24 小时过期
    }
}
```

---

### 2.2 会话管理

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **Session 超时** | 配置合理的会话超时时间 | [ ] | |
| **并发控制** | 限制同一用户并发登录数 | [ ] | |
| **登出处理** | 登出时销毁会话 | [ ] | |
| **记住登录** | "记住我"功能使用持久化 Token | [ ] | |

---

### 2.3 权限控制

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **接口鉴权** | 所有接口验证用户身份 | [ ] | |
| **资源权限** | 用户只能访问自己的资源 | [ ] | |
| **角色权限** | 实施基于角色的访问控制 | [ ] | |
| **权限注解** | 使用注解声明权限要求 | [ ] | |

**正确示例**：
```java
// 接口鉴权拦截器
@Component
public class AuthInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // 白名单：登录、注册等接口
        String uri = request.getRequestURI();
        if (isWhitelisted(uri)) {
            return true;
        }

        // 验证 Token
        String token = request.getHeader("Authorization");
        if (!validateToken(token)) {
            throw new UnauthorizedException("未授权访问");
        }

        return true;
    }
}

// 资源权限检查
@Service
public class OrderService {
    public OrderVO getOrder(Long orderId, Long userId) {
        Order order = orderMapper.selectById(orderId);

        // 检查订单是否属于当前用户
        if (!order.getUserId().equals(userId)) {
            throw new ForbiddenException("无权访问此订单");
        }

        return toVO(order);
    }
}
```

---

## 3. 数据保护

### 3.1 敏感数据加密

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **密码加密** | 密码使用 BCrypt 加密存储 | [ ] | |
| **敏感字段** | 手机号、身份证等敏感信息加密 | [ ] | |
| **传输加密** | 生产环境强制 HTTPS | [ ] | |
| **数据库加密** | 敏感表使用透明加密 | [ ] | |

---

### 3.2 数据隐私

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **最小化原则** | 只收集必要的用户信息 | [ ] | |
| **数据脱敏** | 日志中敏感信息脱敏 | [ ] | |
| **数据保留** | 制定数据保留和删除策略 | [ ] | |
| **隐私政策** | 提供隐私政策说明 | [ ] | |

**正确示例**：
```java
// 日志脱敏
@Slf4j
public class OrderService {
    public void createOrder(OrderDTO dto) {
        // 错误 - 直接输出
        // log.info("用户 {} 创建订单", dto.getUserId());

        // 正确 - 脱敏输出
        String maskedUserId = maskUserId(dto.getUserId());
        log.info("用户 {} 创建订单", maskedUserId);
    }

    private String maskUserId(Long userId) {
        String idStr = userId.toString();
        if (idStr.length() <= 4) return "****";
        return idStr.substring(0, 2) + "****" + idStr.substring(idStr.length() - 2);
    }
}
```

---

### 3.3 数据库安全

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **最小权限** | 数据库用户最小权限原则 | [ ] | |
| **备份加密** | 数据库备份文件加密 | [ ] | |
| **审计日志** | 启用数据库审计日志 | [ ] | |
| **定期备份** | 实施定期备份策略 | [ ] | |

---

## 4. 输入验证

### 4.1 前端验证

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **表单验证** | 所有表单有客户端验证 | [ ] | |
| **类型验证** | 验证数据类型和格式 | [ ] | |
| **长度限制** | 限制输入长度 | [ ] | |
| **文件上传** | 验证文件类型和大小 | [ ] | |

**正确示例**：
```typescript
// 前端表单验证
interface UserRegisterForm {
  username: string;
  password: string;
  email: string;
  phone: string;
}

const validateForm = (data: UserRegisterForm): string[] => {
  const errors: string[] = [];

  // 用户名验证
  if (!data.username || data.username.length < 3 || data.username.length > 20) {
    errors.push('用户名长度必须在3-20字符之间');
  }

  // 密码验证
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;
  if (!passwordRegex.test(data.password)) {
    errors.push('密码必须包含大小写字母和数字，至少8位');
  }

  // 邮箱验证
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(data.email)) {
    errors.push('邮箱格式不正确');
  }

  // 手机号验证
  const phoneRegex = /^1[3-9]\d{9}$/;
  if (!phoneRegex.test(data.phone)) {
    errors.push('手机号格式不正确');
  }

  return errors;
};
```

---

### 4.2 后端验证

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **@Valid 注解** | 使用 @Valid 进行参数校验 | [ ] | |
| **业务规则** | 验证业务规则 | [ ] | |
| **白名单验证** | 使用白名单而非黑名单 | [ ] | |
| **文件验证** | 服务端验证上传文件 | [ ] | |

**正确示例**：
```java
@Data
public class UserRegisterDTO {

    @NotBlank(message = "用户名不能为空")
    @Length(min = 3, max = 20, message = "用户名长度必须在3-20之间")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "用户名只能包含字母、数字和下划线")
    private String username;

    @NotBlank(message = "密码不能为空")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$",
             message = "密码必须包含大小写字母和数字，至少8位")
    private String password;

    @Email(message = "邮箱格式不正确")
    private String email;

    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
}

@RestController
public class UserController {
    @PostMapping("/register")
    public Result<Void> register(@Valid @RequestBody UserRegisterDTO dto) {
        // 验证通过后的逻辑
    }
}
```

---

## 5. API 安全

### 5.1 接口保护

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **认证白名单** | 明确定义无需认证的接口 | [ ] | |
| **接口鉴权** | 受保护接口验证用户身份 | [ ] | |
| **请求限流** | 实施接口访问限流 | [ ] | |
| **请求签名** | 关键接口验证请求签名 | [ ] | |

**正确示例**：
```java
@Configuration
public class SecurityConfig {

    // 公开接口白名单
    private static final String[] WHITELIST = {
        "/api/user/login",
        "/api/user/register",
        "/api/coffee/list",
        "/api/coffee/detail"
    };

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers(WHITELIST).permitAll()
                .anyRequest().authenticated()
            );
        return http.build();
    }
}
```

```java
// 接口限流
@Component
public class RateLimitInterceptor implements HandlerInterceptor {

    private final RateLimiter rateLimiter = RateLimiter.create(100); // 100 QPS

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        if (!rateLimiter.tryAcquire()) {
            throw new RateLimitExceededException("请求过于频繁，请稍后再试");
        }
        return true;
    }
}
```

---

### 5.2 数据返回

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **敏感信息过滤** | 响应不包含敏感信息 | [ ] | |
| **错误信息** | 错误响应不暴露系统信息 | [ ] | |
| **堆栈跟踪** | 生产环境不返回堆栈信息 | [ ] | |

**正确示例**：
```java
// 错误示例 - 暴露敏感信息
@ExceptionHandler(Exception.class)
public Result<Void> handleException(Exception e) {
    return Result.error(e.getMessage()); // 可能暴露系统信息
}

// 正确示例 - 统一错误处理
@ExceptionHandler(Exception.class)
public Result<Void> handleException(Exception e) {
    log.error("系统错误", e); // 详细日志记录在服务器
    return Result.error("系统错误，请稍后重试"); // 用户看到友好提示
}

// VO 类过滤敏感字段
@Data
public class UserVO {
    private Long id;
    private String username;
    // private String password; // 不返回密码
    // private String phone;    // 不返回手机号
}
```

---

## 6. 配置安全

### 6.1 配置文件

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **密钥分离** | 密钥不存储在代码中 | [ ] | |
| **环境变量** | 敏感配置使用环境变量 | [ ] | |
| **配置文件** | 配置文件不提交到版本控制 | [ ] | |
| **加密配置** | 敏感配置使用加密存储 | [ ] | |

**正确示例**：
```yaml
# application.yml - 不包含敏感信息
spring:
  datasource:
    url: ${DB_URL:jdbc:mysql://localhost:3306/coffee_store}
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD}
  jpa:
    hibernate:
      ddl-auto: ${DDL_AUTO:update}

jwt:
  secret: ${JWT_SECRET}
  expiration: ${JWT_EXPIRATION:86400000}
```

```bash
# .env 文件（不提交到版本控制）
DB_URL=jdbc:mysql://localhost:3306/coffee_store
DB_USERNAME=root
DB_PASSWORD=your-password
JWT_SECRET=your-jwt-secret
```

```gitignore
# .gitignore
.env
application-local.yml
application-prod.yml
```

---

### 6.2 生产配置

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **调试关闭** | 生产环境关闭调试模式 | [ ] | |
| **HTTPS** | 强制使用 HTTPS | [ ] | |
| **安全头** | 配置安全响应头 | [ ] | |
| **CORS** | CORS 配置合理 | [ ] | |

**正确示例**：
```yaml
# application-prod.yml
spring:
  profiles:
    active: prod
  devtools:
    restart:
      enabled: false
  freemarker:
    cache: true

server:
  ssl:
    enabled: true
    key-store: classpath:keystore.p12
    key-store-password: ${KEYSTORE_PASSWORD}
    key-store-type: PKCS12
```

```java
// 安全响应头配置
@Configuration
public class SecurityHeaderConfig {
    @Bean
    public FilterRegistrationBean<SecurityHeaderFilter> securityHeaderFilter() {
        FilterRegistrationBean<SecurityHeaderFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new SecurityHeaderFilter());
        registration.addUrlPatterns("/*");
        return registration;
    }
}

public class SecurityHeaderFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
        HttpServletResponse resp = (HttpServletResponse) response;
        resp.setHeader("X-Content-Type-Options", "nosniff");
        resp.setHeader("X-Frame-Options", "DENY");
        resp.setHeader("X-XSS-Protection", "1; mode=block");
        resp.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
        resp.setHeader("Content-Security-Policy", "default-src 'self'");
        chain.doFilter(request, response);
    }
}
```

---

## 7. 依赖安全

### 7.1 第三方依赖

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **漏洞扫描** | 定期扫描依赖漏洞 | [ ] | |
| **版本更新** | 及时更新有漏洞的依赖 | [ ] | |
| **最小依赖** | 只引入必要的依赖 | [ ] | |
| **来源可信** | 使用可信的依赖源 | [ ] | |

**正确示例**：
```bash
# 前端依赖检查
npm audit
npm audit fix

# 后端依赖检查 (Maven)
mvn org.owasp:dependency-check-maven:check
```

---

### 7.2 开源协议

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **许可证检查** | 确认依赖的许可证兼容 | [ ] | |
| **合规使用** | 遵守开源协议要求 | [ ] | |

---

## 8. 部署安全

### 8.1 容器安全

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **最小镜像** | 使用最小化基础镜像 | [ ] | |
| **非 root 用户** | 容器不以 root 用户运行 | [ ] | |
| **只读文件系统** | 容器文件系统只读 | [ ] | |
| **资源限制** | 设置容器资源限制 | [ ] | |

**正确示例**：
```dockerfile
# Dockerfile - 后端
FROM eclipse-temurin:17-jre-alpine

# 创建非 root 用户
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

# 只读文件系统
VOLUME /tmp
VOLUME /logs

# 复制应用
COPY --chown=spring:spring target/*.jar app.jar

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

ENTRYPOINT ["java", "-jar", "/app.jar"]
```

```yaml
# docker-compose.yml
version: '3.8'
services:
  backend:
    image: my-coffee-store-backend:latest
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '1'
          memory: 512M
    read_only: true
    tmpfs:
      - /tmp
    environment:
      - SPRING_PROFILES_ACTIVE=prod
```

---

### 8.2 网络安全

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **网络隔离** | 服务间网络隔离 | [ ] | |
| **防火墙** | 配置防火墙规则 | [ ] | |
| **端口暴露** | 只暴露必要端口 | [ ] | |
| **内网隔离** | 数据库不直接暴露 | [ ] | |

---

## 9. 审计与监控

### 9.1 安全审计

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **操作日志** | 记录关键操作日志 | [ ] | |
| **异常日志** | 记录安全相关异常 | [ ] | |
| **日志保护** | 日志防篡改 | [ ] | |
| **定期审计** | 定期审计安全日志 | [ ] | |

---

### 9.2 安全监控

| 检查项 | 检查方法 | 通过 | 问题记录 |
|--------|----------|------|----------|
| **异常检测** | 监控异常访问行为 | [ ] | |
| **入侵检测** | 部署入侵检测系统 | [ ] | |
| **告警机制** | 安全事件及时告警 | [ ] | |

---

## 10. 安全检查总结

### 检查结果统计

| 类别 | 检查项 | 通过 | 不通过 | 通过率 |
|------|--------|------|--------|--------|
| 注入攻击防护 | 4 | [ ] | [ ] | [ ] |
| 认证与授权 | 3 | [ ] | [ ] | [ ] |
| 数据保护 | 3 | [ ] | [ ] | [ ] |
| 输入验证 | 2 | [ ] | [ ] | [ ] |
| API 安全 | 2 | [ ] | [ ] | [ ] |
| 配置安全 | 2 | [ ] | [ | [ ] |
| 依赖安全 | 2 | [ ] | [ ] | [ ] |
| 部署安全 | 2 | [ ] | [ ] | [ ] |
| 审计与监控 | 2 | [ ] | [ ] | [ ] |
| **总计** | **22** | [ ] | [ ] | [ ] |

### 安全等级评定

- [ ] **优秀**：通过率 ≥ 95%，无 P0 问题
- [ ] **良好**：通过率 ≥ 85%，无 P0 问题
- [ ] **合格**：通过率 ≥ 70%，P0 问题 ≤ 2
- [ ] **不合格**：通过率 < 70% 或存在 P0 问题 > 2

### 整改建议

（根据检查结果，提供具体的整改建议和优先级）

---

*文档版本：1.0*
*最后更新：2026-02-26*

# MyCoffeeStore 代码质量标准

> 版本：1.0
> 创建时间：2026-02-26
> 适用项目：MyCoffeeStore 咖啡店网站

---

## 1. 前端代码规范

### 1.1 React 函数式组件规范

#### 1.1.1 组件定义

**必须使用函数式组件**：
```typescript
// 正确示例
import React from 'react';

interface Props {
  title: string;
  onClick: () => void;
}

export const CoffeeCard: React.FC<Props> = ({ title, onClick }) => {
  return <div onClick={onClick}>{title}</div>;
};

// 错误示例 - 禁止使用类组件
export class CoffeeCard extends React.Component {
  // ...
}
```

**组件命名规范**：
- 使用 PascalCase 命名组件
- 组件文件名与组件名保持一致
- 页面组件放在 `pages/` 目录
- 可复用组件放在 `components/` 目录

#### 1.1.2 Hooks 使用规范

**Hooks 调用规则**：
```typescript
// 正确 - Hooks 在顶层调用
export const UserProfile: React.FC = () => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // 副作用逻辑
  }, []);

  return <div>{user?.name}</div>;
};

// 错误 - Hooks 在条件语句中调用
export const UserProfile: React.FC = () => {
  if (condition) {
    const [state, setState] = useState(null); // 错误
  }
  return <div />;
};
```

**自定义 Hook 命名**：
- 必须以 `use` 开头
- 使用 camelCase 命名
- 返回值类型明确

```typescript
// 正确示例
interface UseCartReturn {
  items: CartItem[];
  total: number;
  addItem: (item: CartItem) => void;
}

export const useCart = (): UseCartReturn => {
  // ...
};
```

#### 1.1.3 状态管理规范

**优先级**：
1. 本地状态：使用 `useState`
2. 跨组件状态：使用 Context API
3. 全局状态：使用 Context API（项目规模小，不引入 Redux）

**Context 使用规范**：
```typescript
// 正确 - 创建类型安全的 Context
interface AuthContextType {
  user: User | null;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  // ...
};

// 使用自定义 Hook 访问 Context
export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```

---

### 1.2 TypeScript 类型规范

#### 1.2.1 类型定义完整性

**禁止使用 `any`**：
```typescript
// 错误
const processData = (data: any) => {
  return data.map((item: any) => item.name);
};

// 正确
interface User {
  id: number;
  name: string;
  email: string;
}

const processData = (data: User[]): string[] => {
  return data.map(item => item.name);
};
```

**接口定义规范**：
```typescript
// API 响应类型
interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
}

// 分页响应
interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  pageSize: number;
}

// 实体类型
interface Coffee {
  id: number;
  name: string;
  description: string;
  price: number;
  category: CoffeeCategory;
  imageUrl: string;
  stock: number;
  status: CoffeeStatus;
}

enum CoffeeCategory {
  LATTE = 'latte',
  ESPRESSO = 'espresso',
  AMERICANO = 'americano',
  COLD_BREW = 'cold_brew',
}

enum CoffeeStatus {
  AVAILABLE = 1,
  UNAVAILABLE = 0,
}
```

#### 1.2.2 类型导出规范

```typescript
// types/coffee.ts
export interface Coffee {
  id: number;
  name: string;
  // ...
}

export enum CoffeeCategory {
  // ...
}

export type CoffeeListResponse = ApiResponse<Coffee[]>;
```

---

### 1.3 ESLint 规则配置

#### 1.3.1 核心 ESLint 配置

```json
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:react-hooks/recommended",
    "plugin:react/recommended",
    "plugin:jsx-a11y/recommended"
  ],
  "rules": {
    "react/react-in-jsx-scope": "off",
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "@typescript-eslint/no-explicit-any": "error",
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn",
    "no-console": ["warn", { "allow": ["warn", "error"] }]
  }
}
```

#### 1.3.2 强制规则说明

| 规则 | 级别 | 说明 |
|------|------|------|
| `@typescript-eslint/no-explicit-any` | error | 禁止使用 any 类型 |
| `@typescript-eslint/no-unused-vars` | error | 禁止未使用的变量 |
| `react-hooks/rules-of-hooks` | error | Hooks 使用规则检查 |
| `react-hooks/exhaustive-deps` | warn | useEffect 依赖检查 |
| `no-console` | warn | 限制 console 使用 |

---

### 1.4 性能最佳实践

#### 1.4.1 组件性能优化

**使用 React.memo 优化重渲染**：
```typescript
import React, { memo } from 'react';

interface CoffeeCardProps {
  coffee: Coffee;
  onAddToCart: (coffee: Coffee) => void;
}

export const CoffeeCard = memo<CoffeeCardProps>(({ coffee, onAddToCart }) => {
  return (
    <div className="coffee-card">
      {/* ... */}
    </div>
  );
}, (prevProps, nextProps) => {
  // 自定义比较逻辑
  return prevProps.coffee.id === nextProps.coffee.id;
});
```

**使用 useMemo 和 useCallback**：
```typescript
export const CoffeeList: React.FC = () => {
  const [coffees, setCoffees] = useState<Coffee[]>([]);
  const [filter, setFilter] = useState<string>('all');

  // 缓存过滤结果
  const filteredCoffees = useMemo(() => {
    return coffees.filter(coffee =>
      filter === 'all' || coffee.category === filter
    );
  }, [coffees, filter]);

  // 缓存回调函数
  const handleAddToCart = useCallback((coffee: Coffee) => {
    // 添加到购物车逻辑
  }, []); // 空依赖数组，函数引用稳定

  return (
    <div>
      {filteredCoffees.map(coffee => (
        <CoffeeCard
          key={coffee.id}
          coffee={coffee}
          onAddToCart={handleAddToCart}
        />
      ))}
    </div>
  );
};
```

#### 1.4.2 列表渲染优化

```typescript
// 正确 - 使用稳定的 key
{coffees.map(coffee => (
  <CoffeeCard key={coffee.id} coffee={coffee} />
))}

// 错误 - 使用索引作为 key
{coffees.map((coffee, index) => (
  <CoffeeCard key={index} coffee={coffee} />
))}
```

#### 1.4.3 代码分割与懒加载

```typescript
import { lazy, Suspense } from 'react';

// 路由级别的代码分割
const CoffeeDetail = lazy(() => import('./pages/CoffeeDetail'));
const Order = lazy(() => import('./pages/Order'));

// 使用 Suspense 包裹
<Suspense fallback={<LoadingSpinner />}>
  <CoffeeDetail />
</Suspense>
```

---

### 1.5 安全检查规范

#### 1.5.1 XSS 防护

**React 默认防护**：
```typescript
// React 自动转义，安全
const userContent = '<script>alert("XSS")</script>';
return <div>{userContent}</div>; // 渲染为纯文本

// 危险操作 - 需要额外验证
return <div dangerouslySetInnerHTML={{ __html: sanitizedContent }} />;
```

**用户输入净化**：
```typescript
import DOMPurify from 'dompurify';

// 净化用户输入
const SafeHtml: React.FC<{ content: string }> = ({ content }) => {
  const clean = DOMPurify.sanitize(content, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a'],
    ALLOWED_ATTR: ['href']
  });

  return <div dangerouslySetInnerHTML={{ __html: clean }} />;
};
```

#### 1.5.2 CSRF 防护

```typescript
// API 请求配置
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.VITE_API_URL,
  withCredentials: true, // 发送 Cookie
});

// 请求拦截器 - 添加 CSRF Token
api.interceptors.request.use((config) => {
  const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
  if (csrfToken) {
    config.headers['X-CSRF-Token'] = csrfToken;
  }
  return config;
});
```

#### 1.5.3 敏感信息保护

```typescript
// 环境变量使用
const API_URL = import.meta.env.VITE_API_URL;

// 错误示例 - 不要在代码中硬编码敏感信息
// const API_KEY = 'sk-1234567890'; // 错误

// LocalStorage 使用注意
// 不要存储敏感信息
localStorage.setItem('token', token); // 谨慎使用
// 更好的方式：使用 httpOnly Cookie
```

---

### 1.6 前端通用规范

#### 1.6.1 文件组织结构

```
src/
├── pages/              # 页面组件
│   ├── Home.tsx
│   ├── Login.tsx
│   └── CoffeeList.tsx
├── components/         # 可复用组件
│   ├── ui/            # 基础 UI 组件
│   └── business/      # 业务组件
├── hooks/             # 自定义 Hooks
├── services/          # API 服务
├── types/             # TypeScript 类型
├── utils/             # 工具函数
├── constants/         # 常量定义
└── styles/            # 样式文件
```

#### 1.6.2 命名规范

| 类型 | 规范 | 示例 |
|------|------|------|
| 组件 | PascalCase | `CoffeeCard.tsx` |
| 工具函数 | camelCase | `formatPrice.ts` |
| 常量 | UPPER_SNAKE_CASE | `API_BASE_URL` |
| 类型/接口 | PascalCase | `UserProfile` |
| 枚举 | PascalCase | `OrderStatus` |
| CSS 类名 | kebab-case | `.coffee-card` |

#### 1.6.3 注释规范

```typescript
/**
 * 咖啡卡片组件
 *
 * @description 展示单个咖啡产品信息，包含图片、名称、价格和添加到购物车按钮
 * @param {Coffee} coffee - 咖啡产品数据
 * @param {Function} onAddToCart - 添加到购物车回调函数
 * @returns {JSX.Element} 咖啡卡片 JSX 元素
 *
 * @example
 * ```tsx
 * <CoffeeCard
 *   coffee={{ id: 1, name: '拿铁', price: 5.50 }}
 *   onAddToCart={(coffee) => console.log(coffee)}
 * />
 * ```
 */
export const CoffeeCard: React.FC<CoffeeCardProps> = ({ coffee, onAddToCart }) => {
  // ...

  // 处理添加到购物车事件
  const handleAddClick = useCallback(() => {
    onAddToCart(coffee);
  }, [coffee, onAddToCart]);

  return <div onClick={handleAddClick}>{/* ... */}</div>;
};
```

---

## 2. 后端代码规范

### 2.1 Java 编码规范

#### 2.1.1 基本编码规范

遵循 **阿里巴巴 Java 开发手册** 规范：

**命名规范**：
```java
// 类名使用 PascalCase
public class UserService {
    // ...
}

// 方法名使用 camelCase
public User getUserById(Long id) {
    // ...
}

// 常量使用 UPPER_SNAKE_CASE
public static final String DEFAULT_AVATAR = "default.png";

// 变量使用 camelCase
private String userName;
```

**代码格式**：
- 使用 4 空格缩进
- 每行最长 120 字符
- 方法长度不超过 80 行
- 类长度不超过 500 行

#### 2.1.2 Lombok 使用规范

```java
// 实体类 - 使用 @Data
@Data
@Entity
@Table(name = "coffee")
public class Coffee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private BigDecimal price;

    private LocalDateTime createTime;
}

// 构造器 - 明确使用 @AllArgsConstructor 或 @RequiredArgsConstructor
@RequiredArgsConstructor  // 只生成 final 字段的构造器
public class OrderService {
    private final OrderMapper orderMapper;
    private final CoffeeService coffeeService;
}

// 日志 - 使用 @Slf4j
@Slf4j
@Service
public class UserService {
    public void login(String username) {
        log.info("User login attempt: {}", username);
        // ...
    }
}
```

#### 2.1.3 Optional 使用规范

```java
// 正确使用 Optional
public Optional<Coffee> getCoffeeById(Long id) {
    return coffeeMapper.selectOneById(id);
}

// 避免 Optional 作为字段类型
public class Coffee {
    private String name;
    // 错误
    // private Optional<String> description;
}

// 链式调用
public CoffeeDTO getCoffeeDetail(Long id) {
    return coffeeMapper.selectOneById(id)
        .map(this::toDTO)
        .orElseThrow(() -> new BusinessException("咖啡不存在"));
}
```

---

### 2.2 Spring Boot 最佳实践

#### 2.2.1 分层架构规范

```
com.coffee
├── controller/      # 控制层 - 处理 HTTP 请求
├── service/         # 服务层 - 业务逻辑
├── mapper/          # 数据访问层 - MyBatis Mapper
├── entity/          # 实体类 - 数据库表映射
├── dto/             # 数据传输对象
├── vo/              # 视图对象
├── config/          # 配置类
├── exception/       # 异常处理
├── enums/           # 枚举类
├── util/            # 工具类
└── constant/        # 常量类
```

**层间调用规则**：
```java
// Controller -> Service -> Mapper
@RestController
@RequestMapping("/api/coffee")
public class CoffeeController {

    @Autowired
    private CoffeeService coffeeService;

    @GetMapping("/list")
    public Result<List<CoffeeVO>> list() {
        return Result.success(coffeeService.getAllCoffees());
    }
}

@Service
public class CoffeeServiceImpl implements CoffeeService {

    @Autowired
    private CoffeeMapper coffeeMapper;

    @Override
    public List<CoffeeVO> getAllCoffees() {
        return coffeeMapper.selectList()
            .stream()
            .map(this::toVO)
            .collect(Collectors.toList());
    }
}
```

#### 2.2.2 依赖注入规范

```java
// 推荐 - 构造器注入
@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderMapper orderMapper;
    private final CoffeeService coffeeService;
}

// 可接受 - 字段注入（用于测试）
@Service
public class UserService {
    @Autowired
    private UserMapper userMapper;
}

// 不推荐 - Setter 注入
```

#### 2.2.3 事务管理规范

```java
@Service
public class OrderServiceImpl implements OrderService {

    // 正确 - 在 Service 方法上使用 @Transactional
    @Transactional(rollbackFor = Exception.class)
    public void createOrder(OrderDTO orderDTO) {
        // 1. 创建订单
        Order order = new Order();
        // ...

        // 2. 扣减库存
        coffeeService.reduceStock(orderDTO.getItems());

        // 3. 如果有异常，自动回滚
    }

    // 查询方法使用只读事务
    @Transactional(readOnly = true)
    public List<OrderVO> getUserOrders(Long userId) {
        // ...
    }
}
```

#### 2.2.4 参数校验规范

```java
// 使用 @Valid 进行参数校验
@RestController
@RequestMapping("/api/user")
public class UserController {

    @PostMapping("/register")
    public Result<Void> register(@Valid @RequestBody UserRegisterDTO dto) {
        userService.register(dto);
        return Result.success();
    }
}

// DTO 中定义校验规则
@Data
public class UserRegisterDTO {

    @NotBlank(message = "用户名不能为空")
    @Length(min = 3, max = 20, message = "用户名长度必须在3-20之间")
    private String username;

    @NotBlank(message = "密码不能为空")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$",
             message = "密码必须包含大小写字母和数字，至少8位")
    private String password;

    @Email(message = "邮箱格式不正确")
    private String email;

    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
}
```

---

### 2.3 MyBatis-Flex 使用规范

#### 2.3.1 实体类定义

```java
@Data
@Schema(description = "咖啡产品实体")
@Table("coffee")
public class Coffee {

    @Id(keyType = KeyType.Auto)
    @Schema(description = "咖啡ID")
    private Long id;

    @Column("name")
    @Schema(description = "咖啡名称")
    private String name;

    @Column("description")
    @Schema(description = "咖啡描述")
    private String description;

    @Column("price")
    @Schema(description = "咖啡价格")
    private BigDecimal price;

    @Column("category")
    @Schema(description = "咖啡分类")
    private String category;

    @Column("image_url")
    @Schema(description = "图片URL")
    private String imageUrl;

    @Column("stock")
    @Schema(description = "库存数量")
    private Integer stock;

    @Column("status")
    @Schema(description = "状态：1-上架 0-下架")
    private Integer status;

    @Column(onInsertValue = "now()")
    @Schema(description = "创建时间")
    private LocalDateTime createTime;
}
```

#### 2.3.2 Mapper 接口定义

```java
/**
 * 咖啡产品 Mapper
 *
 * @author MyCoffeeStore Team
 * @since 2026-02-26
 */
@Mapper
public interface CoffeeMapper extends BaseMapper<Coffee> {

    /**
     * 根据分类查询咖啡列表
     *
     * @param category 分类
     * @return 咖啡列表
     */
    List<Coffee> selectByCategory(String category);

    /**
     * 查询热销咖啡
     *
     * @param limit 限制数量
     * @return 咖啡列表
     */
    List<Coffee> selectTopSelling(int limit);
}
```

#### 2.3.3 查询构建规范

```java
@Service
public class CoffeeServiceImpl implements CoffeeService {

    @Autowired
    private CoffeeMapper coffeeMapper;

    @Override
    public Page<CoffeeVO> searchCoffees(CoffeeSearchDTO dto) {
        // 使用 QueryWrapper 构建查询条件
        QueryWrapper query = QueryWrapper.create()
            .select()
            .from(COFFEE)
            .where(COFFEE.STATUS.eq(1))
            .and(COFFEE.NAME.like(dto.getKeyword(), dto.getKeyword() != null))
            .and(COFFEE.CATEGORY.eq(dto.getCategory(), dto.getCategory() != null))
            .orderBy(COFFEE.CREATE_TIME.desc())
            .page(dto.getPageNum(), dto.getPageSize());

        Page<Coffee> page = coffeeMapper.paginate(query);
        return page.convert(this::toVO);
    }
}
```

---

### 2.4 安全检查规范

#### 2.4.1 SQL 注入防护

```java
// 正确 - 使用参数化查询
@Select("SELECT * FROM coffee WHERE id = #{id}")
Coffee selectById(Long id);

@Select("SELECT * FROM coffee WHERE name LIKE CONCAT('%', #{keyword}, '%')")
List<Coffee> selectByKeyword(String keyword);

// 错误 - 字符串拼接 SQL
// @Select("SELECT * FROM coffee WHERE id = " + id)
// Coffee selectById(Long id);

// 使用 MyBatis-Flex QueryWrapper（自动防护）
QueryWrapper query = QueryWrapper.create()
    .select()
    .from(COFFEE)
    .where(COFFEE.ID.eq(userId));  // 自动参数化
```

#### 2.4.2 XSS 防护

```java
// 配置 XSS 过滤器
@Configuration
public class SecurityConfig {

    @Bean
    public FilterRegistrationBean<XssFilter> xssFilterRegistration() {
        FilterRegistrationBean<XssFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new XssFilter());
        registration.addUrlPatterns("/*");
        registration.setName("xssFilter");
        registration.setOrder(1);
        return registration;
    }
}

// XSS 过滤器实现
public class XssFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
        XssHttpServletRequestWrapper wrappedRequest = new XssHttpServletRequestWrapper((HttpServletRequest) request);
        chain.doFilter(wrappedRequest, response);
    }
}
```

#### 2.4.3 密码安全规范

```java
@Service
public class UserServiceImpl implements UserService {

    // 使用 BCrypt 加密
    private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    @Override
    public void register(UserRegisterDTO dto) {
        // 检查用户名是否已存在
        if (userMapper.selectByUsername(dto.getUsername()).isPresent()) {
            throw new BusinessException("用户名已存在");
        }

        // 加密密码
        String encodedPassword = passwordEncoder.encode(dto.getPassword());

        User user = new User();
        user.setUsername(dto.getUsername());
        user.setPassword(encodedPassword);
        // ...

        userMapper.insert(user);
    }

    @Override
    public String login(String username, String password) {
        User user = userMapper.selectByUsername(username)
            .orElseThrow(() -> new BusinessException("用户名或密码错误"));

        // 验证密码
        if (!passwordEncoder.matches(password, user.getPassword())) {
            throw new BusinessException("用户名或密码错误");
        }

        // 生成 JWT Token
        return jwtUtil.generateToken(user.getId());
    }
}
```

#### 2.4.4 API 访问控制

```java
// JWT 拦截器
@Component
public class JwtInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // 放行登录、注册接口
        String uri = request.getRequestURI();
        if (uri.contains("/login") || uri.contains("/register")) {
            return true;
        }

        // 验证 Token
        String token = request.getHeader("Authorization");
        if (token == null || !jwtUtil.validateToken(token)) {
            throw new UnauthorizedException("未授权访问");
        }

        return true;
    }
}
```

---

### 2.5 异常处理规范

#### 2.5.1 统一异常处理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    // 业务异常
    @ExceptionHandler(BusinessException.class)
    public Result<Void> handleBusinessException(BusinessException e) {
        log.warn("Business exception: {}", e.getMessage());
        return Result.error(e.getMessage());
    }

    // 参数校验异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<Void> handleValidationException(MethodArgumentNotValidException e) {
        String message = e.getBindingResult().getAllErrors().get(0).getDefaultMessage();
        return Result.error(message);
    }

    // 未授权异常
    @ExceptionHandler(UnauthorizedException.class)
    public Result<Void> handleUnauthorizedException(UnauthorizedException e) {
        return Result.error(401, e.getMessage());
    }

    // 系统异常
    @ExceptionHandler(Exception.class)
    public Result<Void> handleException(Exception e) {
        log.error("System error", e);
        return Result.error("系统错误，请稍后重试");
    }
}
```

#### 2.5.2 自定义异常

```java
// 业务异常
@Getter
public class BusinessException extends RuntimeException {
    private final String message;

    public BusinessException(String message) {
        super(message);
        this.message = message;
    }
}

// 未授权异常
public class UnauthorizedException extends RuntimeException {
    public UnauthorizedException(String message) {
        super(message);
    }
}
```

---

### 2.6 后端通用规范

#### 2.6.1 统一响应格式

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result<T> {

    @Schema(description = "响应码")
    private Integer code;

    @Schema(description = "响应消息")
    private String message;

    @Schema(description = "响应数据")
    private T data;

    public static <T> Result<T> success() {
        return new Result<>(200, "success", null);
    }

    public static <T> Result<T> success(T data) {
        return new Result<>(200, "success", data);
    }

    public static <T> Result<T> error(String message) {
        return new Result<>(500, message, null);
    }

    public static <T> Result<T> error(Integer code, String message) {
        return new Result<>(code, message, null);
    }
}
```

#### 2.6.2 日志规范

```java
@Slf4j
@Service
public class OrderServiceImpl implements OrderService {

    @Override
    public OrderVO createOrder(OrderDTO dto) {
        log.info("开始创建订单, userId: {}, items: {}", dto.getUserId(), dto.getItems());

        try {
            // 业务逻辑
            Order order = buildOrder(dto);
            orderMapper.insert(order);

            log.info("订单创建成功, orderId: {}", order.getId());
            return toVO(order);

        } catch (Exception e) {
            log.error("订单创建失败, userId: {}, error: {}", dto.getUserId(), e.getMessage(), e);
            throw new BusinessException("订单创建失败");
        }
    }
}
```

#### 2.6.3 API 接口规范

```java
@RestController
@RequestMapping("/api/order")
@Tag(name = "订单管理", description = "订单相关接口")
@RequiredArgsConstructor
public class OrderController {

    private final OrderService orderService;

    /**
     * 创建订单
     *
     * @param dto 订单信息
     * @return 订单ID
     */
    @PostMapping("/create")
    @Operation(summary = "创建订单")
    public Result<Long> createOrder(@Valid @RequestBody OrderDTO dto) {
        Long orderId = orderService.createOrder(dto);
        return Result.success(orderId);
    }

    /**
     * 查询订单详情
     *
     * @param orderId 订单ID
     * @return 订单详情
     */
    @GetMapping("/detail")
    @Operation(summary = "查询订单详情")
    public Result<OrderVO> getDetail(@RequestParam Long orderId) {
        OrderVO order = orderService.getOrderDetail(orderId);
        return Result.success(order);
    }
}
```

---

## 3. 通用规范

### 3.1 Git 提交信息规范

#### 3.1.1 提交信息格式

```
<type>(<scope>): <subject>

<body>

<footer>
```

**类型 (type)**：
- `feat`: 新功能
- `fix`: 修复 Bug
- `docs`: 文档更新
- `style`: 代码格式（不影响功能）
- `refactor`: 重构
- `perf`: 性能优化
- `test`: 测试相关
- `chore`: 构建/工具相关

**作用域 (scope)**：
- `frontend`: 前端相关
- `backend`: 后端相关
- `api`: API 接口
- `ui`: UI 组件
- `auth`: 认证授权
- `order`: 订单模块

#### 3.1.2 提交示例

```bash
# 新功能
git commit -m "feat(frontend): add coffee list page with filter"

# 修复 Bug
git commit -m "fix(backend): resolve shopping cart calculation error

The total price calculation was incorrect when adding multiple items
with the same coffee ID. Fixed by using quantity in the calculation."

# 重构
git commit -m "refactor(backend): extract common pagination logic

Moved pagination logic from each service to a common utility class
to reduce code duplication."
```

#### 3.1.3 提交规范检查

```bash
# 使用 commitlint 检查提交信息
npm install --save-dev @commitlint/cli @commitlint/config-conventional

# commitlint.config.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [2, 'always', ['feat', 'fix', 'docs', 'style', 'refactor', 'test', 'chore']],
    'type-case': [2, 'always', 'lower-case'],
    'scope-case': [2, 'always', 'kebab-case'],
    'subject-empty': [2, 'never'],
    'subject-max-length': [2, 'always', 72],
  },
};
```

---

### 3.2 代码注释规范

#### 3.2.1 Java 注释规范

```java
/**
 * 订单服务实现类
 *
 * <p>负责订单的创建、查询、状态更新等核心业务逻辑</p>
 *
 * @author MyCoffeeStore Team
 * @since 2026-02-26
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {

    /**
     * 创建订单
     *
     * <p>订单创建流程：
     * <ol>
     *   <li>验证用户信息和咖啡库存</li>
     *   <li>计算订单总价</li>
     *   <li>创建订单记录</li>
     *   <li>扣减咖啡库存</li>
     *   <li>清空用户购物车</li>
     * </ol>
     *
     * @param dto 订单数据传输对象
     * @return 创建的订单视图对象
     * @throws BusinessException 当咖啡库存不足时抛出
     * @see OrderDTO
     * @see OrderVO
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public OrderVO createOrder(OrderDTO dto) {
        // 实现逻辑
    }
}
```

#### 3.2.2 TypeScript 注释规范

```typescript
/**
 * 咖啡列表服务
 *
 * @module services/coffee
 */

/**
 * 获取咖啡列表
 *
 * @description 根据分类和关键词筛选咖啡产品
 *
 * @param params - 查询参数
 * @param params.category - 咖啡分类（可选）
 * @param params.keyword - 搜索关键词（可选）
 * @param params.page - 页码，默认 1
 * @param params.pageSize - 每页数量，默认 10
 *
 * @returns Promise<CoffeeListResponse> 咖啡列表响应
 *
 * @throws {ApiError} 当网络请求失败时抛出
 *
 * @example
 * ```typescript
 * const coffees = await getCoffeeList({
 *   category: 'latte',
 *   page: 1,
 *   pageSize: 10
 * });
 * ```
 */
export const getCoffeeList = async (params: {
  category?: string;
  keyword?: string;
  page?: number;
  pageSize?: number;
}): Promise<CoffeeListResponse> => {
  // 实现逻辑
};
```

---

### 3.3 命名规范汇总

#### 3.3.1 Java 命名规范

| 类型 | 命名规则 | 示例 |
|------|----------|------|
| 类名 | PascalCase | `OrderService` |
| 接口 | PascalCase，可选 I 前缀 | `UserService` / `IUserService` |
| 方法名 | camelCase，动词开头 | `getUserById`, `createOrder` |
| 变量名 | camelCase | `userName`, `totalPrice` |
| 常量 | UPPER_SNAKE_CASE | `MAX_RETRY_COUNT` |
| 包名 | 全小写，点分隔 | `com.coffee.service` |
| 枚举类 | PascalCase | `OrderStatus` |
| 枚举值 | UPPER_SNAKE_CASE | `PENDING`, `COMPLETED` |

#### 3.3.2 TypeScript 命名规范

| 类型 | 命名规则 | 示例 |
|------|----------|------|
| 组件 | PascalCase | `CoffeeCard`, `OrderList` |
| 接口 | PascalCase，可选 I 前缀 | `User`, `IUser` |
| 类型 | PascalCase | `CoffeeDTO`, `ApiResponse` |
| 枚举 | PascalCase | `OrderStatus` |
| 变量/函数 | camelCase | `userName`, `fetchData` |
| 常量 | UPPER_SNAKE_CASE | `API_BASE_URL` |
| 文件名 | camelCase（函数）/ PascalCase（组件） | `utils.ts`, `CoffeeCard.tsx` |

#### 3.3.3 数据库命名规范

| 类型 | 命名规则 | 示例 |
|------|----------|------|
| 表名 | snake_case，小写 | `user`, `coffee_order` |
| 字段名 | snake_case，小写 | `user_id`, `create_time` |
| 索引名 | `idx_表名_字段名` | `idx_user_email` |
| 外键名 | `fk_表名_字段名` | `fk_order_user_id` |
| 主键名 | `id`（简化）或 `表名_id` | `id`, `user_id` |

---

## 4. 文档要求

### 4.1 代码文档

**必须包含文档的代码**：
- 所有公共 API 接口
- 所有公开类和接口
- 复杂业务逻辑方法
- 工具类和工具函数

### 4.2 API 文档

使用 Swagger/OpenAPI 自动生成：

```java
@Tag(name = "订单管理", description = "订单创建、查询、管理接口")
@RestController
@RequestMapping("/api/order")
public class OrderController {

    @Operation(summary = "创建订单", description = "根据购物车内容创建新订单")
    @ApiResponses({
        @ApiResponse(responseCode = "200", description = "创建成功"),
        @ApiResponse(responseCode = "400", description = "参数错误"),
        @ApiResponse(responseCode = "500", description = "服务器错误")
    })
    @PostMapping("/create")
    public Result<Long> createOrder(@Valid @RequestBody OrderDTO dto) {
        // ...
    }
}
```

---

## 5. 质量门禁

### 5.1 代码提交前检查

- [ ] ESLint/Checkstyle 检查通过
- [ ] 单元测试通过
- [ ] 代码格式化完成
- [ ] 自我审查完成

### 5.2 代码合并前检查

- [ ] 至少一人 Code Review
- [ ] 所有测试用例通过
- [ ] 无安全漏洞
- [ ] 文档更新完整

---

*文档版本：1.0*
*最后更新：2026-02-26*
